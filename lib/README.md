在上一篇之后,我们已经通过 loader 已经可以跳转到了内核,下一步我们就要开始写内核了,在写之前,我们需要了解一下特权级,目前的特权级有 4 级,分别为 0,1,2,3 级,目前我们只使用了两个特权级,操作系统是 0 级是最高的特权级别,用户级别是 3 级,是最低的特权级别

### 什么是 TSS ?

TSS是一个很重要的数据结构就是,他的主要作用是负责特权级转换和描述任务状态,我们这里简单介绍一下 TSS ,之后会在实现进程的时候详细解释.

![](https://img2018.cnblogs.com/i-beta/824400/202001/824400-20200118194913264-1924072149.png)

在 TSS 图上,TSS 结构偏移 4 到 偏移 27的三个栈指针,包括 ss 和 esp ,对应 4 个特权级,一个任务最多有 4 个栈(一般只用3个),每个特权级会用到一个独立的栈,这样做主要是因为如果他们公用一个栈容易导致交叉引用引起混乱,而且一个栈也比较容易导致溢出.

虽然有 4 个栈,但是只需要三个特权级指针,因为特权级转换有两种情况,低特权级转高特权级需要通过 TSS 获取高特权级的esp,但是在高特权级转低特权级的时候,在这之前一般都会有低转高,这种情况不需要用到 TSS ,因为在低转高的时候已经进行了压栈,只需要从高的栈里面获取到低的栈的esp值就行了,没有比3特权级还低的,所以就不需要存了.

其实 TSS 中还可以保存所有的寄存器,从而实现任务切换,但是目前没有操作系统在使用 TSS 做任务切换(这样说可能不准确,之后进程部分会详细藐视),在加上现在内核只使用了 0 特权级和 3 特权级,因此现在我们使用 TSS 只关心 esp0 , IO位图 , SS.

### 什么是当前特权级别?

上文提到了特权级这个概念,这里就来解释一下特权级相关的概念.

需要明确一点，当前处于什么**特权是相对于处理器而言**的，例如，我们可以说如果处理器在执行内核代码，处理器就处于特权级别0。

其次，需要知道特权下的访问者是谁，**访问者是指令**，对于处理器来说，只有指令是被执行的。

我们怎样才知道**当前的特权级别等级**（CPL)是什么，既然处理器无时无刻不在执行指令，而且指令为访问者，我们用当前执行的指令的特权等级作为当前特权级别等级，但一条指令并不会指定它自己的特权级别，指令肯定是在某个代码段里面，而代码段是有自己的特权级别等级的，所以CPU用**当前执行的代码段**的**特权级别**作为当前特权级别等级。

![](https://img2018.cnblogs.com/i-beta/824400/202001/824400-20200118215643800-1777679949.png)

　　段描述符的 DPL 就是描述某个段的特权级别，每个段都有自己的特权级别。结合上面所说的，当前执行代码段的 DPL = CPL 。

　　那么 CPL 需要有个地方保存，这样子处理器才能知道自己是处在什么特权级别。而这个地方就是选择子，准确来说的选择子中的 RPL 部分。

　　选择子在哪里存储的？段寄存器。代码段寄存器是 CS ，所以 CS 中的 RPL = CPL，我们写作 CS.RPL=CPL ，综上，**当前代码段 DPL = CPL = CS.RPL** 。

简单的说:

- CPL : CPU 当前特权级，等于 CS 段描述符的 DPL 值,等于当前 CS 段选择子的 RPL(CS.RPL)
- DPL : 如果你想访问我这个段，你应该具备什么样的权限
- RPL : 用什么权限去访问一个段 ，用于解决CPU"越权"问题

一般而言，低特权级别是不能访问高特权级别的资源，但高特权级别能访问低特权级别的资源。现在看来只有段描述符是有特权级别的，当然后面也有像门结构描述符也有 DPL ，下面只谈论“段”。

　　所以我们分别讨论一下代码段和数据段（这里除代码段以外都称为数据段）：

　　这里以三个例子来讨论一般规则。

　　①如果受访者是数据段，且特权级别为2，处于哪些特权等级的访问者可以访问？

　　遵循一般原则，只有高于或等于受访者的特权等级才能访问。所以只有处于特权级别0、1、2的访问才能对数据段进行访问。即**数值上访问者的特权级别小于等于受访者的特权级别**。

　　②如果受访者是非一致性代码段，且特权级别为2，处于哪些特权级别的访问者可以访问？

　　首先比受访者特权级别低的访问者肯定是不能直接访问了，这得遵循一般原则。所以我们不能通过 jmp 或 call 等指令跳到或调用特权等级较高的代码。

　　然后比受访者特权级别高的访问者可不可以访问呢？就是访问者能访问比自己特权级别低的代码段吗?不能，书上的解释是：低特权等级能做的事，高特权等级也能做，所以高特权等级没有必要跳到低特权等级里执行，访问者没有必要自降等级去做它本来能做的事情。凡是都有例外，唯一一种从高特权等级跳到低特权等级的情况是：从中断服务程序返回到用户态。

　　综上只有**平级的访问者才能访问非一致性代码段**，即特权级别为2才能访问。

　　③如果受访者是一致性代码段，且特权级别为2，处于哪些特权级别的访问者可以访问？

　　**一致性代码段能让比自己特权级别低的访问者访问**，所以特权级别3，2的访问者可以访问。注意访问者转移到一致性代码段后，转移后的特权级别还是和转移前一样，这是一致性代码段得到特点，一致性代码段不以自己的特权级别等级为主。

　　特权级别检查发生在访问受访者的一瞬间，之后访问这个受访者段里的内容都不需要再检查了。

### 门结构

当Intel CPU运行在32位保护模式下时，需要使用中断描述符表（Interrupt Descriptor Table，IDT）来管理中断或异常。IDT是Intel 8086～80186 CPU中使用的中断向量表的直接替代物。其作用也类似于中断向量表，只是其中每个中断描述符项中除了含有中断服务程序地址以外，还包含有关特权级和描述符类别等信息。Linux操作系统工作于80x86的保护模式下，因此它使用中断描述符表来设置和保存各中断的"向量"信息。

参考

- https://www.cnblogs.com/thougr/p/12210220.html