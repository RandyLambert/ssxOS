该目录下实现了简易的 mbr 与 loader ,Intel 8086 有20条地址线,因此可以访问 1MB 的内存空间,是 0x00000 到 0xFFFFF,为了解 mbr 和 loader 的作用,我们先看看在 intel 8086 中,实模式下的 1MB 内存布局是什么样子

| 起始  | 结束  | 大小 | 用途                                                         |
| ----- | ----- | ---- | ------------------------------------------------------------ |
| FFFF0 | FFFFF | 16B  | BIOS 入口地址,此地址属于BIOS 代码,当操作系统刚开始加载时, CPU 默认 CS:IP 值为ffff:0000,通过此部分是16字节的跳转指令, jmp f000:e05b 跳转到入口 |
|F0000|FFFEF|64KB-16B|系统BIOS范围是F0000～FFFFF共64KB,最上面16字节为入口地址|
|C8000|EFFFF|160KB|映射硬件适配器的ROM或内存映射式I/O|
|C0000|C7FFF|32KB|显示适配器BIOS|
|B8000|BFFFF|32KB|用于文本模式显示适配器|
|B0000|B7FFF|32KB|用于黑白显示适配器|
|A0000|AFFFF|64KB|用于彩色显示适配器|
|9FC00|9FFFF|1KB|扩展BIOS数据区|
|7E00|9FBFF|622080B|可用区域|
|7C00|7DFF|512B|MBR被BIOS加载到此处，共512字节|
|500|7BFF|30464B|可用区域|
|400|4FF|256B|BIOS数据区|
|000|3FF|1KB|Interrupt Vector Table（中断向量表）|

因为20位地址线只能映射 1MB 的地址,而这 1MB 映射了 DRAM , ROM 和显卡三部分.

地址 0x00000-0x9FFFF 这部分内存是 DRAM ,也就是插在主板上的内存条(地址总线不完全只能访问电脑中的内存条),这部分的空间范围是 640KB .

中间的 0xA0000-0xEFFFF 这部分主要留给其他一些需要通过地址总线访问的外设,因此我们不能把所有的地址完全映射到 DRAM ,因此提前预留这部分的地址空间给外设用,比如显存,硬盘控制器等,留够以后,地址总线上其他的可用地址在指向 DRAM ,也就是我们指的插到主板上的内存调,我们眼中的物理内存.

顶部的 0xF0000-0xFFFFF  这部分是 ROM ,这里面存放的是 BIOS 的代码, BIOS 主要工作是检测和初始化硬件,怎么初始化的?硬件自己提供了一些初始化的功能调用, BIOS 直接调用就好. BIOS 还建立的中断向量表,这样就可以通过"int 中断号"来实现相关的硬件调用了,当然BIOS建立的这些功能就是对硬件的IO操作,也就是输入输出,但由于就 64KB 大小的空间,不可能把所有硬件的IO操作实现得面面俱到,而且也没必要实现那么多,毕竟是在实模式之下,对硬件支持得再丰富也白搭,精彩的世界是在进入保护模式以后才开始,所以挑一些重要的,保证计算机能运行的那些硬件的基本IO操作,这就是BIOS称为基本输入输出系统的原因.

机器加电时,进入的实模式, CPU 访问 CS*16+EIP 这个地址,CS段寄存器值为0xF000,EIP值为0x0000FFF0,所以机器启动时CPU将访问0xFFFF0(该地址为BIOS入口地址),实模式下1M地址中的0xF0000-0xFFFFF这个内存地址就是ROM,其存储的就是BIOS代码(16字节大小：`JMP F000:E05B`),接着CPU执行地址为 0xFE05B 中的指令,而系统 BIOS 范围是 F0000～FFFFF ,此属于BIOS代码,为BIOS程序的真正内容.

因为 BIOS 在 ROM 中,所以不能更改(也没有更改的必要),因此我们只需要知道他做了什么事情就可以了,在上述检测进行完之后,最后一项工作是校验启动盘中位于0盘0道1扇区的内容(即 MBR )

## MBR (主引导记录)

1. MBR 只能是 512 字节,而且最后两字节为0x55,0xaa(魔数).

2. MBR 冲虚段的入口地址为0x7c00 ,所以在 MBR 的代码中我们可以看到 SECTION MBR vstart=0x7c00 的设置.

3. 将硬盘的0盘0道1扇区填充为 MBR 程序的内容(通过 dd 命令),然后给计算机配置此硬盘为启动盘,这样计算机启动时,就能够自动从BIOS到MBR了.

### 此操作系统 MBR 中主要做了什么?

通过 ROM 中默认的 BIOS 程序,我们成功进入了 MBR 程序,在 MBR 中我们主要干了下面几件事情.

1. 输出字符串 MBR
2. 从磁盘的第二扇区读取 loader (这个可以随意放,我选择放在第二扇区),将读取的内容存到 0x900 这个内存地址中,之后当 mbr jmp 到了 0x900 是,就会执行 0x900 这块地址的指令,也就是 loader 中的内容 
3. 因为按照规定 MBR 的大小必须是 512 字节,而且最后两个字节必须是魔数0x55,0xaa,因此在代码的最后如果不足 512 字节,还需要用类似与 times 510-($-$$) db 0 这样的指令凑满 512 字节

### 此操作系统 loader 主要做了什么?

当 mbr 跳转到 loader 之后,就到来 loader 大显身手的时候了,在 loader 程序中我们主要做这几件事情.

1. 我们通过上文提到的 BIOS 中断获取整个计算机中的物理内存
2. 跳转进入保护模式,因此需要在 loader.S 中定义代码段,数据段,显示段,还要定义页表(我采用二级页表的形式).
3. 加载内核

这里牵扯到了新的概念,**保护模式是什么,为什么要有保护模式?**

### 为什么要有保护模式?

在实模式下,操作系统和用户程序是属于同一特权级的没有区别,逻辑地址就直接对应物理地址,用户程序是可以通过修改段机制访问到所有地址,很显然这样很不安全,除此之外,在访问内存的时候,需要不断的更换段基址,因为一个段的大小只有 64KB ,内存一共也只有 1M ,并且每次只能运行一个程序,这显然不能适应现在多核的场景,因此就有了带有分段机制的保护模式.

### 保护模式有什么特点?

1. 保护模式赋予不同的进程不同的特权等级,操作系统为最高的 0 级,用户进程为 3 级,将用户资源和操作系统资源隔离,更加安全.
2. CPU 和操作系统通过分段机制,根据段描述符(8字节,是描述段的结构,信息包括段基质,段界限,段类型,段是否可读,段的方向(由低到高还是由高到低)等等)
3. 在 CPU 发展到 32 位后,地址总线和数据总线扩展到来 32 位,通用寄存器的大小也扩展为 32 位,这样能访问的内存空间编程了 4G ,可以不需要段基址了,不过兼容性依旧保存了段基址+偏移地址的访问方式来访问最终的物理地址,这也就是传说中的平坦模式.这里有个概念需要明确一下,是什么模式以处理器是多少位并没有关系,即使是 32 位系统,在刚开机时都是实模式,只有在经过 loader 的一系列操作之后,才会变为保护模式.

### 分段机制概述

上文提到了段描述符,一个段描述符保存一个段的信息,有一个专门的数据结构保存着多个段描述符,称为描述符表, 80386/80486 CPU 共有3 种描述符表:全局描述符表( GDT ),局部描述符表( LDT )和中断描述符表( IDT ).描述符表由描述符顺序排列组成,占一定的内存.

段描述符是一个 8 字节 64 位的结构.

![](https://img2018.cnblogs.com/blog/824400/201911/824400-20191116210635975-1349509255.png)

在低32位中 0-15 位和32位 16-19 位代表段界限,描述段能达到的边界,具体的边界值要结合 23 位的 G 来看, G 为 1 是,笔叟暗示段界限的粒度为4 KB,G = 0 时,表示段界限的粒度为 1 Byte,实际的段界限 - (段描述符里的段界限 + 1) * 段界限粒度大小 - 1.低 32 位的 16-31 位和高 32 位的 0-7 位及 24-31 位共同描述段基址的 32 位,因为历史遗留原因,为了把段基址扩展到 32 位,把段界限扩展为 20 位,只能继续往后面添加,所以会段界限和段基址会分散在不同的地方.

　　S 代表一个段是系统段还是数据段,在 CPU 眼里,凡是硬件使用到的东西称为系统,凡是软件使用到的东西称为数据,所以代码段,数据段,栈段等也属于 S 中所代表的的数据段.

　　Type 指定段的类型,一共四位.只有S决定了,Type才有它的意义.下图是Type在系统段和数据段里不同的意义.

![](https://img2018.cnblogs.com/blog/824400/201911/824400-20191116211927143-64867343.png)

![](https://img2018.cnblogs.com/blog/824400/201911/824400-20191116212005141-1752668595.png)

我们主要看一下数据段下Type的意义。当段为代码段时，Type由X、R、C、A组成，分别代表是否可执行、是否可读、是否一致、是否被访问过。当段位数据段时，Type由X、W、E、A组成，分别代表是否可执行、是否可写、扩展方向、是否被访问过。

　　DPL代表段属于哪一个特权级别。

　　P代表内存段是否存在，0代表段不存在，1代表段存在。

　　AVL代表可用的位,操作系统可以随意使用,没有特殊含义。

　　L代表代码段是64位还是32位。

　　D/B。对于代码段来说此位是D，用来给代码段指定是使用16位还是32位有效地址和操作数的。对于栈段来说此位是B，用来给栈段指定使用的是sp寄存器还是esp寄存器，sp寄存器的最大寻址范围是0xFFFF,esp寄存器的最大寻址范围是0xFFFFFFFF。

　　G代表段界限的粒度，是4KB还是1B。

　　全局描述符表示共用的，多个程序都可以在这个表定义自己的段描述符。我们进入保护模式的其中一个步骤之一就是加载全局描述符表，让CPU知道全局描述符表的位置，在操作内存的时候，CPU就会根据描述符的信息检查这操作是否有效。

### A20 地址线

　　在实模式下，A20地址线是默认禁用的，原因是还未进入保护模式之前，地址总线还是要模拟20位的效果，即只保留20位以内的地址，如果地址超过20位，地址就会回绕到0，将地址20位（从0开始算）舍弃，所以要将A20地址线给禁用掉。但进入保护模式后，我们需要恢复地址总线的原貌，即使地址超过20位，地址也不应该回绕到0，所以此时将A20地址线打开，我们就能访问超过20位的地址了。因此，打开A20地址线，是进入保护模式的步骤之一。

### CR0 的 PE 位

进入保护模式的最后一个步骤是，打开CR0的PE位，CR0是控制寄存器。控制寄存器是CPU的窗口，它既可以展示CPU的内部状态，也可以控制CPU的运行机制。CR0的第0位，PE位，就是保护模式的开关，我们打开PE位，就是告诉CPU接下来我们要进入保护模式。

### 进入保护模式 

由上面可以知道，进入保护模式的步骤如下：

　　1. 打开 A20 地址线
  　　2. 加载 GDT
  　　3. 将 CR0 的 PE 位置为 1

另一个值得注意的指令是：jmp dword SELECTOR_CODE:p_mode_start，这个指令是用来刷新流水线的，因为在进入保护模式之前，p_mode_start后面的指令也会被放上流水线，指令会按照16位译码，其实本来应该按照32位译码才能正常执行，所以我们需要清除流水线上的这些指令，保证这些指令按32位译码，这样才能正常地运行下去。

### 分页模式

经过了一系列操作,终于实现了分段,操作系统也进入了保护模式,分段模式解决了一些实模式留下的问题,但是分段模式还有一个缺陷没有解决.

- 由于分段模式是以进程为单位分配内存的,本来剩余的内存空间是足以分配给进程的，但由于这些剩余的内存片并不连续，我们就不能分配这些内存给对应的进程了。

因此,为了解决这个问题,就有了分页模式,分页就是通过映射的方式，将连续的线性地址转化为不连续的物理地址；这样，在处理器进入分页模式之后，用户直接访问的并不是物理地址，而是分页模式下的虚拟地址。

注意:分段是分页的基础,段页式的内存布局映射如下

![](https://img2018.cnblogs.com/blog/824400/202001/824400-20200106153119975-495609776.png)

